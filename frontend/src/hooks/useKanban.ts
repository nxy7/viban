import { eq, inArray } from "@tanstack/db";
import { useLiveQuery } from "@tanstack/solid-db";

export * from "~/lib/generated/ash";

import * as sdk from "~/lib/generated/ash";
import type { AshRpcError } from "~/lib/generated/ash";

import {
  syncBoardsCollection as boardsCollection,
  syncColumnsCollection as columnsCollection,
  syncTasksCollection as tasksCollection,
  syncHooksCollection as hooksCollection,
  syncColumnHooksCollection as columnHooksCollection,
  syncRepositoriesCollection as repositoriesCollection,
  syncTaskEventsCollection as taskEventsCollection,
} from "~/lib/generated/sync/collections";

import type {
  KanbanBoard,
  KanbanColumn,
  KanbanTask,
  KanbanHook,
  KanbanColumnHook,
  KanbanRepository,
  KanbanTaskEvent,
} from "~/lib/generated/sync/schema";

export {
  boardsCollection,
  columnsCollection,
  tasksCollection,
  hooksCollection,
  columnHooksCollection,
  repositoriesCollection,
  taskEventsCollection,
};

export type {
  KanbanBoard,
  KanbanColumn,
  KanbanTask,
  KanbanHook,
  KanbanColumnHook,
  KanbanRepository,
  KanbanTaskEvent,
};

export type Board = KanbanBoard;
export type Column = KanbanColumn;
export type Task = KanbanTask;
export type Hook = KanbanHook;
export type ColumnHook = KanbanColumnHook;
export type Repository = KanbanRepository;
export type TaskEvent = KanbanTaskEvent;

export function unwrap<T>(
  result:
    | { success: true; data: T }
    | { success: false; errors: AshRpcError[] },
): T | null {
  return result.success ? result.data : null;
}

export function toDecimal(n: number): number {
  return n;
}

// ============================================================================
// Additional Type Interfaces (not generated by AshSync)
// ============================================================================

export interface ColumnSettings {
  max_concurrent_tasks?: number | null;
  description?: string | null;
  auto_move_on_complete?: boolean;
  require_confirmation?: boolean;
  hooks_enabled?: boolean;
  [key: string]: unknown;
}

export interface Subtask {
  id: string;
  title: string;
  description: string | null;
  priority: "low" | "medium" | "high";
  column_id: string;
  position: number;
  subtask_position: number;
  agent_status: "idle" | "thinking" | "executing" | "error" | null;
  agent_status_message: string | null;
}

export type HookKind = "script" | "agent";
export type AgentExecutor =
  | "claude_code"
  | "gemini_cli"
  | "codex"
  | "opencode"
  | "cursor_agent";

export interface SystemHook {
  id: string;
  name: string;
  description: string;
  is_system: true;
  hook_kind: "script";
  command: null;
}

export interface CombinedHook {
  id: string;
  name: string;
  description: string | null;
  hook_kind: HookKind;
  command: string | null;
  agent_prompt: string | null;
  agent_executor: AgentExecutor | null;
  agent_auto_approve: boolean | null;
  is_system: boolean;
  default_execute_once: boolean | null;
  default_transparent: boolean | null;
}

// ============================================================================
// Electric SQL Query Hooks
// ============================================================================

interface QueryHookResult<T> {
  data: () => T;
  isLoading: () => boolean;
  error: () => string | null;
}

interface LiveQueryResult {
  data: unknown[];
  isLoading: () => boolean;
  isError: () => boolean;
  status: () => string;
}

function createQueryResult<T>(
  query: LiveQueryResult,
  defaultValue: T,
): QueryHookResult<T> {
  return {
    data: () => (query.data as T) ?? defaultValue,
    isLoading: () => query.isLoading(),
    error: () => (query.isError() ? String(query.status()) : null),
  };
}

export function useBoards() {
  const query = useLiveQuery((q) =>
    q.from({ boards: boardsCollection }).select(({ boards }) => ({
      id: boards.id,
      name: boards.name,
      description: boards.description,
      inserted_at: boards.inserted_at,
      updated_at: boards.updated_at,
    })),
  );

  const result = createQueryResult<Board[] | undefined>(query, undefined);
  return {
    boards: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useBoard(boardId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = boardId();
    if (!id) return undefined;

    return q
      .from({ boards: boardsCollection })
      .where(({ boards }) => eq(boards.id, id))
      .select(({ boards }) => ({
        id: boards.id,
        name: boards.name,
        description: boards.description,
        inserted_at: boards.inserted_at,
        updated_at: boards.updated_at,
      }));
  });

  const result = createQueryResult<Board[]>(query, []);
  return {
    board: () => (result.data().length > 0 ? result.data()[0] : null),
    isLoading: result.isLoading,
    error: result.error,
  };
}

function parseColumnSettings(
  settings: string | ColumnSettings | Record<string, unknown> | null,
): ColumnSettings {
  if (settings === null) return {};
  if (typeof settings === "string") {
    try {
      return JSON.parse(settings) as ColumnSettings;
    } catch {
      return {};
    }
  }
  return (settings as ColumnSettings) || {};
}

export function useColumns(boardId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = boardId();
    if (!id) return undefined;

    return q
      .from({ columns: columnsCollection })
      .where(({ columns }) => eq(columns.board_id, id))
      .orderBy(({ columns }) => columns.position, "asc")
      .select(({ columns }) => ({
        id: columns.id,
        board_id: columns.board_id,
        name: columns.name,
        position: columns.position,
        color: columns.color,
        settings: columns.settings,
        inserted_at: columns.inserted_at,
        updated_at: columns.updated_at,
      }));
  });

  const result = createQueryResult<KanbanColumn[]>(query, []);
  return {
    columns: () =>
      result.data().map((col) => ({
        ...col,
        settings: parseColumnSettings(col.settings),
      })),
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useTasks(columnId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = columnId();
    if (!id) return undefined;

    return q
      .from({ tasks: tasksCollection })
      .where(({ tasks }) => eq(tasks.column_id, id))
      .orderBy(({ tasks }) => tasks.position, "asc")
      .select(({ tasks }) => ({
        id: tasks.id,
        column_id: tasks.column_id,
        title: tasks.title,
        description: tasks.description,
        position: tasks.position,
        worktree_path: tasks.worktree_path,
        worktree_branch: tasks.worktree_branch,
        custom_branch_name: tasks.custom_branch_name,
        agent_status: tasks.agent_status,
        agent_status_message: tasks.agent_status_message,
        in_progress: tasks.in_progress,
        error_message: tasks.error_message,
        parent_task_id: tasks.parent_task_id,
        is_parent: tasks.is_parent,
        subtask_position: tasks.subtask_position,
        subtask_generation_status: tasks.subtask_generation_status,
        inserted_at: tasks.inserted_at,
        updated_at: tasks.updated_at,
      }));
  });

  const result = createQueryResult<Task[]>(query, []);
  return {
    tasks: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useAllTasks(boardId: () => string | undefined) {
  const { columns } = useColumns(boardId);

  const query = useLiveQuery((q) => {
    const cols = columns();
    if (!cols || cols.length === 0) return undefined;

    const columnIds = cols.map((c) => c.id);
    return q
      .from({ tasks: tasksCollection })
      .where(({ tasks }) => inArray(tasks.column_id, columnIds))
      .orderBy(({ tasks }) => tasks.position, "asc")
      .select(({ tasks }) => ({
        id: tasks.id,
        column_id: tasks.column_id,
        title: tasks.title,
        description: tasks.description,
        position: tasks.position,
        worktree_path: tasks.worktree_path,
        worktree_branch: tasks.worktree_branch,
        custom_branch_name: tasks.custom_branch_name,
        agent_status: tasks.agent_status,
        agent_status_message: tasks.agent_status_message,
        in_progress: tasks.in_progress,
        error_message: tasks.error_message,
        parent_task_id: tasks.parent_task_id,
        is_parent: tasks.is_parent,
        subtask_position: tasks.subtask_position,
        subtask_generation_status: tasks.subtask_generation_status,
        inserted_at: tasks.inserted_at,
        updated_at: tasks.updated_at,
      }));
  });

  const result = createQueryResult<Task[]>(query, []);
  return {
    tasks: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

// ============================================================================
// SDK Re-exports for Direct Use
// ============================================================================
// Use SDK functions directly at callsites with .then(unwrap):
//   sdk.create_task({ input: {..., position: toDecimal(pos)} }).then(unwrap)
//   sdk.move_task({ identity: id, input: { position: toDecimal(pos) } }).then(unwrap)

export interface DescriptionImageInput {
  id: string;
  name: string;
  dataUrl?: string;
}

// ============================================================================
// Hook Queries & Mutations
// ============================================================================

export function useHooks(boardId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = boardId();
    if (!id) return undefined;

    return q
      .from({ hooks: hooksCollection })
      .where(({ hooks }) => eq(hooks.board_id, id))
      .select(({ hooks }) => ({
        id: hooks.id,
        board_id: hooks.board_id,
        name: hooks.name,
        hook_kind: hooks.hook_kind,
        command: hooks.command,
        agent_prompt: hooks.agent_prompt,
        agent_executor: hooks.agent_executor,
        agent_auto_approve: hooks.agent_auto_approve,
        inserted_at: hooks.inserted_at,
        updated_at: hooks.updated_at,
      }));
  });

  const result = createQueryResult<Hook[]>(query, []);
  return {
    hooks: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useColumnHooks(columnId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = columnId();
    if (!id) return undefined;

    return q
      .from({ column_hooks: columnHooksCollection })
      .where(({ column_hooks }) => eq(column_hooks.column_id, id))
      .orderBy(({ column_hooks }) => column_hooks.position, "asc")
      .select(({ column_hooks }) => ({
        id: column_hooks.id,
        column_id: column_hooks.column_id,
        hook_id: column_hooks.hook_id,
        hook_type: column_hooks.hook_type,
        position: column_hooks.position,
        execute_once: column_hooks.execute_once,
        transparent: column_hooks.transparent,
        removable: column_hooks.removable,
        hook_settings: column_hooks.hook_settings,
        inserted_at: column_hooks.inserted_at,
        updated_at: column_hooks.updated_at,
      }));
  });

  const result = createQueryResult<ColumnHook[]>(query, []);
  return {
    columnHooks: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useRepositories(boardId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = boardId();
    if (!id) return undefined;

    return q
      .from({ repositories: repositoriesCollection })
      .where(({ repositories }) => eq(repositories.board_id, id))
      .select(({ repositories }) => ({
        id: repositories.id,
        board_id: repositories.board_id,
        name: repositories.name,
        full_name: repositories.full_name,
        provider: repositories.provider,
        provider_repo_id: repositories.provider_repo_id,
        clone_url: repositories.clone_url,
        html_url: repositories.html_url,
        local_path: repositories.local_path,
        clone_status: repositories.clone_status,
        clone_error: repositories.clone_error,
        default_branch: repositories.default_branch,
        inserted_at: repositories.inserted_at,
        updated_at: repositories.updated_at,
      }));
  });

  const result = createQueryResult<Repository[]>(query, []);
  return {
    repositories: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

// Fetch all hooks (system + custom) for a board - uses REST API
export async function fetchAllHooks(boardId: string): Promise<CombinedHook[]> {
  const response = await fetch(`/api/boards/${boardId}/hooks`);
  const data = await response.json();

  if (!data.ok) {
    throw new Error(data.error || "Failed to fetch hooks");
  }

  return data.hooks;
}

// Fetch system hooks only (no board context needed) - uses REST API
export async function fetchSystemHooks(): Promise<CombinedHook[]> {
  const response = await fetch("/api/hooks/system");
  const data = await response.json();

  if (!data.ok) {
    throw new Error(data.error || "Failed to fetch system hooks");
  }

  return data.hooks;
}

// ============================================================================
// Task Event Queries (unified messages, hooks, sessions)
// ============================================================================

export function useTaskEvents(taskId: () => string | undefined) {
  const query = useLiveQuery((q) => {
    const id = taskId();
    if (!id) return undefined;

    return q
      .from({ events: taskEventsCollection })
      .where(({ events }) => eq(events.task_id, id))
      .orderBy(({ events }) => events.inserted_at, "asc")
      .select(({ events }) => ({
        id: events.id,
        task_id: events.task_id,
        type: events.type,
        status: events.status,
        role: events.role,
        content: events.content,
        hook_name: events.hook_name,
        hook_id: events.hook_id,
        hook_settings: events.hook_settings,
        skip_reason: events.skip_reason,
        error_message: events.error_message,
        queued_at: events.queued_at,
        started_at: events.started_at,
        completed_at: events.completed_at,
        triggering_column_id: events.triggering_column_id,
        executor_type: events.executor_type,
        prompt: events.prompt,
        exit_code: events.exit_code,
        working_directory: events.working_directory,
        session_id: events.session_id,
        sequence: events.sequence,
        metadata: events.metadata,
        inserted_at: events.inserted_at,
        updated_at: events.updated_at,
        column_hook_id: events.column_hook_id,
      }));
  });

  const result = createQueryResult<TaskEvent[]>(query, []);
  return {
    events: result.data,
    isLoading: result.isLoading,
    error: result.error,
  };
}

export function useMessages(taskId: () => string | undefined) {
  const { events, isLoading, error } = useTaskEvents(taskId);

  return {
    messages: () => events().filter((e) => e.type === "message"),
    isLoading,
    error,
  };
}

export function useHookExecutions(taskId: () => string | undefined) {
  const { events, isLoading, error } = useTaskEvents(taskId);

  return {
    hookExecutions: () => events().filter((e) => e.type === "hook_execution"),
    isLoading,
    error,
  };
}

// Pull Request types
export interface Branch {
  name: string;
  is_default: boolean;
}

// ============================================================================
// System Tools Types
// ============================================================================

export type ToolName =
  | "docker"
  | "git"
  | "gh"
  | "claude"
  | "codex"
  | "aider"
  | "goose";

export type ToolCategory = "core" | "optional";

export interface SystemTool {
  name: ToolName;
  display_name: string;
  description: string | null;
  available: boolean;
  version: string | null;
  category: ToolCategory;
  feature: string | null;
}

// ============================================================================
// Type Guards (for Electric SQL data validation)
// ============================================================================

function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

export function isTask(data: unknown): data is Task {
  if (!isObject(data)) return false;
  return (
    typeof data.id === "string" &&
    typeof data.column_id === "string" &&
    typeof data.title === "string"
  );
}

export function isBoard(data: unknown): data is Board {
  if (!isObject(data)) return false;
  return (
    typeof data.id === "string" &&
    typeof data.name === "string" &&
    typeof data.inserted_at === "string"
  );
}

export function isColumn(data: unknown): data is Column {
  if (!isObject(data)) return false;
  return (
    typeof data.id === "string" &&
    typeof data.board_id === "string" &&
    typeof data.name === "string" &&
    typeof data.position === "number"
  );
}

export function validateArray<T>(
  data: unknown,
  guard: (item: unknown) => item is T,
): T[] {
  if (!Array.isArray(data)) return [];
  return data.filter(guard);
}
